
Property changes on: class
___________________________________________________________________
Name: svn:ignore
   + Windows Presentation Foundation - Visual Studio 2005.suo



Property changes on: class\WindowsBase
___________________________________________________________________
Name: svn:ignore
   - TestResult*log
TestResult*xml
*.dll
*.mdb

   + TestResult*log
TestResult*xml
*.dll
*.mdb
bin
obj
WindowsBase tests - Visual Studio 2005.csproj.user
WindowsBase - Visual Studio 2005.csproj.user
WindowsBase tests on Mono - Visual Studio 2005.csproj.user


Index: class/WindowsBase/Test/System.Windows/RectTest.cs
===================================================================
--- class/WindowsBase/Test/System.Windows/RectTest.cs	(revision 0)
+++ class/WindowsBase/Test/System.Windows/RectTest.cs	(revision 0)
@@ -0,0 +1,300 @@
+// RectTest.cs - NUnit Test Cases for System.Windows.Rect
+//
+// George Giolfan (georgegiolfan@yahoo.com)
+//
+// (C) George Giolfan
+// 
+
+using NUnit.Framework;
+using System;
+using System.Globalization;
+using System.Threading;
+using System.Windows;
+
+namespace MonoTests.System.Windows
+{
+
+	[TestFixture]
+	public class RectTest
+	{
+
+		[SetUp]
+		public void GetReady ()
+		{
+		}
+
+		[TearDown]
+		public void Clean ()
+		{
+		}
+
+		[Test]
+		public void X ()
+		{
+			double x = new Rect ().X;
+		}
+
+		[Test]
+		public void ConstructorZero ()
+		{
+			new Rect (0, 0, 0, 0);
+		}
+
+		[Test]
+		[ExpectedException (typeof (ArgumentException), ExpectedMessage = "Width and Height must be non-negative.")]
+		public void ConstructorNegativeWidth ()
+		{
+			new Rect (0, 0, -1, 0);
+		}
+
+		[Test]
+		[ExpectedException (typeof (ArgumentException), ExpectedMessage = "Width and Height must be non-negative.")]
+		public void ConstructorNegativeHeight ()
+		{
+			new Rect (0, 0, 0, -1);
+		}
+
+		[Test]
+		public void Empty ()
+		{
+			Rect empty = Rect.Empty;
+			Assert.IsTrue (double.IsPositiveInfinity (empty.X), "X");
+			Assert.IsTrue (double.IsPositiveInfinity (empty.Y), "Y");
+			Assert.IsTrue (double.IsNegativeInfinity (empty.Width), "Width");
+			Assert.IsTrue (double.IsNegativeInfinity (empty.Height), "Height");
+		}
+
+		[Test]
+		public void IsEmpty ()
+		{
+			Assert.IsTrue (Rect.Empty.IsEmpty, "Empty");
+			Assert.IsFalse (new Rect (0, 0, 0, 0).IsEmpty, "(0, 0, 0, 0)");
+		}
+
+		[Test]
+		[ExpectedException (typeof (ArgumentException), ExpectedMessage = "Width must be non-negative.")]
+		public void WidthNegative ()
+		{
+			Rect rect = new Rect ();
+			rect.Width = -1;
+		}
+
+		[Test]
+		[ExpectedException (typeof (ArgumentException), ExpectedMessage = "Height must be non-negative.")]
+		public void HeightNegative ()
+		{
+			Rect rect = new Rect ();
+			rect.Height = -1;
+		}
+
+		[Test]
+		[ExpectedException (typeof (InvalidOperationException), ExpectedMessage = "Cannot modify this property on the Empty Rect.")]
+		public void EmptyReadOnlyWidth ()
+		{
+			Rect empty = Rect.Empty;
+			empty.Width = 0;
+		}
+
+		[Test]
+		[ExpectedException (typeof (InvalidOperationException), ExpectedMessage = "Cannot modify this property on the Empty Rect.")]
+		public void EmptyReadOnlyHeight ()
+		{
+			Rect empty = Rect.Empty;
+			empty.Height = 0;
+		}
+
+		[Test]
+		[ExpectedException (typeof (InvalidOperationException), ExpectedMessage = "Cannot modify this property on the Empty Rect.")]
+		public void EmptyReadOnlyX ()
+		{
+			Rect empty = Rect.Empty;
+			empty.X = 0;
+		}
+
+		[Test]
+		[ExpectedException (typeof (InvalidOperationException), ExpectedMessage = "Cannot modify this property on the Empty Rect.")]
+		public void EmptyReadOnlyY ()
+		{
+			Rect empty = Rect.Empty;
+			empty.Y = 0;
+		}
+
+		[Test]
+		[ExpectedException (typeof (InvalidOperationException), ExpectedMessage = "Cannot modify this property on the Empty Rect.")]
+		public void EmptyReadOnlyWidthNegativeInfinity ()
+		{
+			Rect empty = Rect.Empty;
+			empty.Width = double.NegativeInfinity;
+		}
+
+		[Test]
+		public void InflateCausesRectangleToBecomeEmpty ()
+		{
+			Rect rect = new Rect ();
+			rect.Inflate (-1, 0);
+			Assert.IsTrue (rect.IsEmpty);
+		}
+
+		[Test]
+		public void IntersectCausesRectangleToBecomeEmpty ()
+		{
+			Rect rect = new Rect (0, 0, 1, 1);
+			rect.Intersect (new Rect (2, 2, 3, 3));
+			Assert.IsTrue (rect.IsEmpty);
+		}
+
+		[Test]
+		public void ConstructorSizeEmpty ()
+		{
+			Rect rect_from_empty_size = new Rect (Size.Empty);
+			Assert.IsTrue (rect_from_empty_size.IsEmpty, "1");
+			Assert.AreEqual (rect_from_empty_size.X, double.PositiveInfinity, "2");
+
+		}
+
+		[Test]
+		public void ConstructorPointSizeEmpty ()
+		{
+			Rect rect_from_empty_size = new Rect (new Point (), Size.Empty);
+			Assert.IsTrue (rect_from_empty_size.IsEmpty, "1");
+			Assert.AreEqual (rect_from_empty_size.X, double.PositiveInfinity, "2");
+
+		}
+
+		[Test]
+		public void Intersect ()
+		{
+			Rect rect = new Rect (1, 1, 2, 2);
+			rect.Intersect (new Rect (2, 2, 2, 2));
+			Assert.AreEqual (rect, new Rect (2, 2, 1, 1));
+		}
+
+		[Test]
+		public void IntersectEmpty ()
+		{
+			Assert.IsTrue (Rect.Intersect (Rect.Empty, new Rect (0, 0, 1, 1)).IsEmpty);
+		}
+
+		[Test]
+		public void IntersectsWith ()
+		{
+			Assert.IsTrue (new Rect ().IntersectsWith (new Rect ()));
+		}
+
+		[Test]
+		public void IntersectsWithEmpty ()
+		{
+			Assert.IsFalse (Rect.Empty.IntersectsWith (Rect.Empty));
+		}
+
+		[Test]
+		public void Parse ()
+		{
+			Assert.AreEqual (Rect.Parse ("1 2 3 4"), new Rect (1, 2, 3, 4));
+		}
+
+		[Test]
+		public void ParseDecimalPlaces ()
+		{
+			Assert.AreEqual (Rect.Parse ("1.1 2.2 3.3 4.4"), new Rect (1.1, 2.2, 3.3, 4.4));
+		}
+
+		[Test]
+		public void ParseDecimalPlacesComma ()
+		{
+			Assert.AreEqual (Rect.Parse ("1.1,2.2,3.3,4.4"), new Rect (1.1, 2.2, 3.3, 4.4));
+		}
+
+		[Test]
+		[ExpectedException (typeof (InvalidOperationException), ExpectedMessage = "Premature string termination encountered.")]
+		public void ParseNull ()
+		{
+			Rect.Parse (null);
+		}
+
+		[Test]
+		[ExpectedException (typeof (InvalidOperationException), ExpectedMessage = "Premature string termination encountered.")]
+		public void ParseEmpty ()
+		{
+			Rect.Parse (string.Empty);
+		}
+
+		[Test]
+		[ExpectedException (typeof (InvalidOperationException), ExpectedMessage = "Premature string termination encountered.")]
+		public void ParseOneNumber ()
+		{
+			Rect.Parse ("0");
+		}
+
+		[Test]
+		[ExpectedException (typeof (FormatException), ExpectedMessage = "Input string was not in a correct format.")]
+		public void ParseOneLetter ()
+		{
+			Rect.Parse ("a");
+		}
+
+		[Test]
+		public void ScaleEmpty ()
+		{
+			Rect rect = Rect.Empty;
+			rect.Scale (0, 0);
+			Assert.IsTrue (rect.IsEmpty);
+		}
+
+		[Test]
+		public void Union ()
+		{
+			Rect rect = new Rect (0, 0, 1, 1);
+			rect.Union (new Rect (-1, -1, 1, 1));
+			Assert.AreEqual (rect, new Rect (-1, -1, 2, 2));
+		}
+
+		[Test]
+		public void UnionEmpty ()
+		{
+			Rect rect = new Rect (0, 0, 1, 1);
+			rect.Union (Rect.Empty);
+			Assert.AreEqual (rect, new Rect (0, 0, 1, 1), "1");
+
+			rect = Rect.Empty;
+			rect.Union (new Rect (0, 0, 1, 1));
+			Assert.AreEqual (rect, new Rect (0, 0, 1, 1), "2");
+		}
+
+		[Test]
+		public void SizeEmpty ()
+		{
+			Rect rect = new Rect ();
+			rect.Size = Size.Empty;
+			Assert.AreEqual (rect.X, double.PositiveInfinity);
+		}
+
+		[Test]
+		public void ToStringInvariantCulture ()
+		{
+			Culture = CultureInfo.InvariantCulture;
+			Assert.AreEqual (new Rect ().ToString (), "0,0,0,0", "1");
+			Assert.AreEqual (new Rect (1.1, 2.2, double.PositiveInfinity, 0).ToString (), "1.1,2.2,Infinity,0", "2");
+			Assert.AreEqual (Rect.Empty.ToString (), "Empty", "4");
+		}
+
+		[Test]
+		public void ToStringRomanianCulture ()
+		{
+			Culture = new CultureInfo ("ro-RO");
+			Assert.AreEqual (new Rect ().ToString (), "0;0;0;0", "1");
+			Assert.AreEqual (new Rect (1.1, 2.2, double.PositiveInfinity, 0).ToString (), "1,1;2,2;Infinity;0", "2");
+			Assert.AreEqual (Rect.Empty.ToString (), "Empty", "4");
+		}
+
+		CultureInfo Culture  {
+			set {
+				Thread current_thread = Thread.CurrentThread;
+				current_thread.CurrentCulture = value;
+				current_thread.CurrentUICulture = value;
+			}
+		}
+
+	}
+
+}
\ No newline at end of file

Property changes on: class\WindowsBase\Test\System.Windows\RectTest.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Index: class/WindowsBase/Test/System.Windows/SizeTest.cs
===================================================================
--- class/WindowsBase/Test/System.Windows/SizeTest.cs	(revision 0)
+++ class/WindowsBase/Test/System.Windows/SizeTest.cs	(revision 0)
@@ -0,0 +1,291 @@
+// SizeTest.cs - NUnit Test Cases for System.Windows.Size
+//
+// George Giolfan (georgegiolfan@yahoo.com)
+//
+// (C) George Giolfan
+// 
+
+using NUnit.Framework;
+using System;
+using System.Collections.Generic;
+using System.Globalization;
+using System.Threading;
+using System.Windows;
+
+namespace MonoTests.System.Windows
+{
+
+	[TestFixture]
+	public class SizeTest
+	{
+
+		[SetUp]
+		public void GetReady ()
+		{
+		}
+
+		[TearDown]
+		public void Clean ()
+		{
+		}
+
+		[Test]
+		public void ConstructorZero ()
+		{
+			new Size (0, 0);
+		}
+
+		[Test]
+		public void ConstructorPositiveInfinity ()
+		{
+			new Size (double.PositiveInfinity, 0);
+		}
+
+		[Test]
+		[ExpectedException (typeof (ArgumentException), ExpectedMessage = "Width and Height must be non-negative.")]
+		public void ConstructorNegativeInfinity ()
+		{
+			new Size (double.NegativeInfinity, 0);
+		}
+
+		[Test]
+		[ExpectedException (typeof (ArgumentException), ExpectedMessage = "Width and Height must be non-negative.")]
+		public void ConstructorNegative ()
+		{
+			new Size (-1, 0);
+		}
+
+		[Test]
+		public void Empty ()
+		{
+			Assert.IsTrue (double.IsNegativeInfinity (Size.Empty.Width), "Empty width");
+			Assert.IsTrue (double.IsNegativeInfinity (Size.Empty.Height), "Empty height");
+		}
+
+		[Test]
+		public void IsEmpty ()
+		{
+			Assert.IsTrue (Size.Empty.IsEmpty, "Empty");
+			Assert.IsFalse (new Size (0, 0).IsEmpty, "(0, 0)");
+		}
+
+		[Test]
+		[ExpectedException (typeof (ArgumentException), ExpectedMessage = "Width must be non-negative.")]
+		public void WidthNegative ()
+		{
+			Size size = new Size ();
+			size.Width = -1;
+		}
+
+		[Test]
+		[ExpectedException (typeof (ArgumentException), ExpectedMessage = "Height must be non-negative.")]
+		public void HeightNegative ()
+		{
+			Size size = new Size ();
+			size.Height = -1;
+		}
+
+		[Test]
+		[ExpectedException (typeof (InvalidOperationException), ExpectedMessage = "Premature string termination encountered.")]
+		public void ParseNull ()
+		{
+			Size.Parse (null);
+		}
+
+		[Test]
+		[ExpectedException (typeof (InvalidOperationException), ExpectedMessage = "Premature string termination encountered.")]
+		public void ParseEmpty ()
+		{
+			Size.Parse (string.Empty);
+		}
+
+		[Test]
+		[ExpectedException (typeof (InvalidOperationException), ExpectedMessage = "Premature string termination encountered.")]
+		public void ParseSpace ()
+		{
+			Size.Parse (" ");
+		}
+
+		[Test]
+		[ExpectedException (typeof (InvalidOperationException), ExpectedMessage = "Premature string termination encountered.")]
+		public void ParseNumber ()
+		{
+			Size.Parse ("0");
+		}
+
+		[Test]
+		public void ParseTwoNumbers ()
+		{
+			Assert.AreEqual (Size.Parse ("0 0"), new Size ());
+		}
+
+		[Test]
+		public void ParseTwoNumbersSeparatedByComma ()
+		{
+			Assert.AreEqual (Size.Parse ("0,0"), new Size ());
+		}
+
+		[Test]
+		[ExpectedException (typeof (FormatException), ExpectedMessage = "Input string was not in a correct format.")]
+		public void ParseTwoNumbersSeparatedBySemicolon ()
+		{
+			Size.Parse ("0;0");
+		}
+
+		[Test]
+		public void ParseTwoNumbersSeparatedByCommaAndSpace ()
+		{
+			Assert.AreEqual (Size.Parse (" 0 , 0 "), new Size ());
+		}
+
+		[Test]
+		[ExpectedException (typeof (FormatException), ExpectedMessage = "Input string was not in a correct format.")]
+		public void ParseTwoNumbersWithBrackets ()
+		{
+			Size.Parse ("(0, 0)");
+		}
+
+		[Test]
+		[ExpectedException (typeof (FormatException), ExpectedMessage = "Input string was not in a correct format.")]
+		public void ParseLetters ()
+		{
+			Size.Parse ("a");
+		}
+
+		[Test]
+		[ExpectedException (typeof (InvalidOperationException), ExpectedMessage = "Extra data encountered after token while parsing.")]
+		public void ParseThreeNumbers ()
+		{
+			Size.Parse ("0 0 0");
+		}
+
+		[Test]
+		[ExpectedException (typeof (FormatException), ExpectedMessage = "Input string was not in a correct format.")]
+		public void ParseThreeLetters ()
+		{
+			Size.Parse ("a a a");
+		}
+
+		[Test]
+		[ExpectedException (typeof (FormatException), ExpectedMessage = "Input string was not in a correct format.")]
+		public void ParsePointWithSpaces ()
+		{
+			Size.Parse ("0 . 0");
+		}
+
+		[Test]
+		[ExpectedException (typeof (InvalidOperationException), ExpectedMessage = "Extra data encountered after token while parsing.")]
+		public void ParsePointAndComma ()
+		{
+			Size.Parse ("1.000,00 0");
+		}
+
+		[Test]
+		public void ParsePoint ()
+		{
+			Assert.AreEqual (Size.Parse ("0.1,0.0"), new Size (0.1, 0));
+		}
+
+
+		[Test]
+		[ExpectedException (typeof (InvalidOperationException), ExpectedMessage = "Extra data encountered after token while parsing.")]
+		public void ParseComma ()
+		{
+			Assert.AreEqual (Size.Parse ("0,0 0,0"), new Size ());
+		}
+
+		[Test]
+		public void IFormattableToStringInvariantCulture ()
+		{
+			Culture = CultureInfo.InvariantCulture;
+			Assert.AreEqual (((IFormattable)new Size ()).ToString (null, null), "0,0", "1");
+			Assert.AreEqual (((IFormattable)new Size (1.1, 2.2)).ToString (null, null), "1.1,2.2", "2");
+			Assert.AreEqual (((IFormattable)new Size (double.PositiveInfinity, 0)).ToString (null, null), "Infinity,0", "3");
+			Assert.AreEqual (((IFormattable)Size.Empty).ToString (null, null), "Empty", "4");
+		}
+
+		[Test]
+		public void IFormattableToStringRomanianCulture ()
+		{
+			Culture = new CultureInfo ("ro-RO");
+			Assert.AreEqual (((IFormattable)new Size ()).ToString (null, null), "0;0", "1");
+			Assert.AreEqual (((IFormattable)new Size (1.1, 2.2)).ToString (null, null), "1,1;2,2", "2");
+			Assert.AreEqual (((IFormattable)new Size (double.PositiveInfinity, 0)).ToString (null, null), "Infinity;0", "3");
+			Assert.AreEqual (((IFormattable)Size.Empty).ToString (null, null), "Empty", "4");
+		}
+
+		[Test]
+		public void IFormattableToStringFormatProviderUsage ()
+		{
+			Culture = CultureInfo.InvariantCulture;
+			TestFormatProvider test_format_provider = new TestFormatProvider ();
+			((IFormattable)new Size ()).ToString (null, test_format_provider);
+			Assert.AreEqual (test_format_provider.Calls.Count, 4, "1");
+			Assert.AreEqual (test_format_provider.Calls [0], typeof (NumberFormatInfo), "2");
+			Assert.AreEqual (test_format_provider.Calls [1], typeof (ICustomFormatter), "3");
+			Assert.AreEqual (test_format_provider.Calls [2], typeof (NumberFormatInfo), "4");
+			Assert.AreEqual (test_format_provider.Calls [3], typeof (NumberFormatInfo), "5");
+		}
+
+		[Test]
+		public void ToStringInvariantCulture ()
+		{
+			Culture = CultureInfo.InvariantCulture;
+			Assert.AreEqual (new Size ().ToString (), "0,0", "1");
+			Assert.AreEqual (new Size (1.1, 2.2).ToString (), "1.1,2.2", "2");
+			Assert.AreEqual (new Size (double.PositiveInfinity, 0).ToString (), "Infinity,0", "3");
+			Assert.AreEqual (Size.Empty.ToString (), "Empty", "4");
+		}
+
+		[Test]
+		public void ToStringRomanianCulture ()
+		{
+			Culture = new CultureInfo ("ro-RO");
+			Assert.AreEqual (new Size ().ToString (), "0;0", "1");
+			Assert.AreEqual (new Size (1.1, 2.2).ToString (), "1,1;2,2", "2");
+			Assert.AreEqual (new Size (double.PositiveInfinity, 0).ToString (), "Infinity;0", "3");
+			Assert.AreEqual (Size.Empty.ToString (), "Empty", "4");
+		}
+
+		[Test]
+		public void ToStringIFormatProviderInvariantCulture ()
+		{
+			Culture = CultureInfo.InvariantCulture;
+			Assert.AreEqual (new Size ().ToString (null), "0,0", "1");
+			Assert.AreEqual (new Size (1.1, 2.2).ToString (null), "1.1,2.2", "2");
+			Assert.AreEqual (new Size (double.PositiveInfinity, 0).ToString (null), "Infinity,0", "3");
+			Assert.AreEqual (Size.Empty.ToString (null), "Empty", "4");
+		}
+
+		[Test]
+		public void ToStringIFormatProviderRomanianCulture ()
+		{
+			Culture = new CultureInfo ("ro-RO");
+			Assert.AreEqual (new Size ().ToString (null), "0;0", "1");
+			Assert.AreEqual (new Size (1.1, 2.2).ToString (null), "1,1;2,2", "2");
+			Assert.AreEqual (new Size (double.PositiveInfinity, 0).ToString (null), "Infinity;0", "3");
+			Assert.AreEqual (Size.Empty.ToString (null), "Empty", "4");
+		}
+
+		CultureInfo Culture {
+			set {
+				Thread current_thread = Thread.CurrentThread;
+				current_thread.CurrentCulture = value;
+				current_thread.CurrentUICulture = value;
+			}
+		}
+
+		class TestFormatProvider : IFormatProvider
+		{
+			public List<Type> Calls = new List<Type> ();
+
+			public object GetFormat (Type formatType)
+			{
+				Calls.Add (formatType);
+				return null;
+			}
+		}
+
+	}
+
+}
\ No newline at end of file

Property changes on: class\WindowsBase\Test\System.Windows\SizeTest.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Index: class/WindowsBase/WindowsBase_test.dll.sources
===================================================================
--- class/WindowsBase/WindowsBase_test.dll.sources	(revision 84156)
+++ class/WindowsBase/WindowsBase_test.dll.sources	(working copy)
@@ -1,2 +1,4 @@
 AttachedProperties.cs
+System.Windows/RectTest.cs
+System.Windows/SizeTest.cs
 System.Windows.Threading/DispatcherTest.cs

Property changes on: class\WindowsBase\WindowsBase_test.dll.sources
___________________________________________________________________
Name: svn:eol-style
   + native

Index: class/WindowsBase/WindowsBase.dll.sources
===================================================================
--- class/WindowsBase/WindowsBase.dll.sources	(revision 84156)
+++ class/WindowsBase/WindowsBase.dll.sources	(working copy)
@@ -1,3 +1,4 @@
+Mono/DoubleListParser.cs
 System.Windows/CoerceValueCallback.cs
 System.Windows/DependencyObject.cs
 System.Windows/DependencyObjectType.cs
Index: class/WindowsBase/WindowsBase - Visual Studio 2005.csproj
===================================================================
--- class/WindowsBase/WindowsBase - Visual Studio 2005.csproj	(revision 0)
+++ class/WindowsBase/WindowsBase - Visual Studio 2005.csproj	(revision 0)
@@ -0,0 +1,90 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>8.0.50727</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{9462AA4B-7F15-46B5-98A3-28832667B7BA}</ProjectGuid>
+    <OutputType>Library</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>
+    </RootNamespace>
+    <AssemblyName>WindowsBase</AssemblyName>
+    <StartupObject>
+    </StartupObject>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>bin\Debug\</OutputPath>
+    <DefineConstants>TRACE;DEBUG;NET_2_0</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>bin\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" />
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+       Other similar extension points exist, see Microsoft.Common.targets.
+  <Target Name="BeforeBuild">
+  </Target>
+  <Target Name="AfterBuild">
+  </Target>
+  -->
+  <ItemGroup>
+    <None Include="ChangeLog" />
+    <None Include="Makefile" />
+    <None Include="System.Windows.Threading\ChangeLog" />
+    <None Include="WindowsBase.dll.sources" />
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="..\..\build\common\Consts.cs">
+      <Link>Consts.cs</Link>
+    </Compile>
+    <Compile Include="..\..\build\common\MonoTODOAttribute.cs">
+      <Link>MonoTODOAttribute.cs</Link>
+    </Compile>
+    <Compile Include="System.Windows.Input\Key.cs" />
+    <Compile Include="System.Windows.Input\ModifierKeys.cs" />
+    <Compile Include="System.Windows.Media\Matrix.cs" />
+    <Compile Include="System.Windows.Threading\Dispatcher.cs" />
+    <Compile Include="System.Windows.Threading\DispatcherFrame.cs" />
+    <Compile Include="System.Windows.Threading\DispatcherHookEventArgs.cs" />
+    <Compile Include="System.Windows.Threading\DispatcherHookEventHandler.cs" />
+    <Compile Include="System.Windows.Threading\DispatcherHooks.cs" />
+    <Compile Include="System.Windows.Threading\DispatcherObject.cs" />
+    <Compile Include="System.Windows.Threading\DispatcherOperation.cs" />
+    <Compile Include="System.Windows.Threading\DispatcherOperationStatus.cs" />
+    <Compile Include="System.Windows.Threading\DispatcherPriority.cs" />
+    <Compile Include="System.Windows.Threading\DispatcherTimer.cs" />
+    <Compile Include="System.Windows\CoerceValueCallback.cs" />
+    <Compile Include="System.Windows\DependencyObject.cs" />
+    <Compile Include="System.Windows\DependencyObjectType.cs" />
+    <Compile Include="System.Windows\DependencyProperty.cs" />
+    <Compile Include="System.Windows\DependencyPropertyChangedEventArgs.cs" />
+    <Compile Include="System.Windows\DependencyPropertyChangedEventHandler.cs" />
+    <Compile Include="System.Windows\DependencyPropertyKey.cs" />
+    <Compile Include="Mono\DoubleListParser.cs" />
+    <Compile Include="System.Windows\IWeakEventListener.cs" />
+    <Compile Include="System.Windows\LocalValueEntry.cs" />
+    <Compile Include="System.Windows\LocalValueEnumerator.cs" />
+    <Compile Include="System.Windows\Point.cs" />
+    <Compile Include="System.Windows\PropertyChangedCallback.cs" />
+    <Compile Include="System.Windows\PropertyMetadata.cs" />
+    <Compile Include="System.Windows\Rect.cs" />
+    <Compile Include="System.Windows\Size.cs" />
+    <Compile Include="System.Windows\ValidateValueCallback.cs" />
+    <Compile Include="System.Windows\Vector.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+  </ItemGroup>
+</Project>
\ No newline at end of file

Property changes on: class\WindowsBase\WindowsBase - Visual Studio 2005.csproj
___________________________________________________________________
Name: svn:eol-style
   + native

Index: class/WindowsBase/WindowsBase tests on Mono - Visual Studio 2005.csproj
===================================================================
--- class/WindowsBase/WindowsBase tests on Mono - Visual Studio 2005.csproj	(revision 0)
+++ class/WindowsBase/WindowsBase tests on Mono - Visual Studio 2005.csproj	(revision 0)
@@ -0,0 +1,62 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>8.0.50727</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{1FC4703A-6989-463D-BB92-6AF2DD9ABF6B}</ProjectGuid>
+    <OutputType>Library</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>
+    </RootNamespace>
+    <AssemblyName>WindowsBase tests on Mono - Visual Studio 2005</AssemblyName>
+    <StartupObject>
+    </StartupObject>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>bin\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>bin\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" />
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+       Other similar extension points exist, see Microsoft.Common.targets.
+  <Target Name="BeforeBuild">
+  </Target>
+  <Target Name="AfterBuild">
+  </Target>
+  -->
+  <ItemGroup>
+    <Compile Include="Test\AttachedProperties.cs" />
+    <Compile Include="Test\System.Windows.Threading\DispatcherTest.cs" />
+    <Compile Include="Test\System.Windows\RectTest.cs" />
+    <Compile Include="Test\System.Windows\SizeTest.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="ChangeLog" />
+    <None Include="Makefile" />
+    <None Include="WindowsBase_test.dll.sources" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="WindowsBase - Visual Studio 2005.csproj">
+      <Project>{9462AA4B-7F15-46B5-98A3-28832667B7BA}</Project>
+      <Name>WindowsBase - Visual Studio 2005</Name>
+    </ProjectReference>
+  </ItemGroup>
+  <ItemGroup>
+    <Reference Include="nunit.framework, Version=2.4.2.0, Culture=neutral, PublicKeyToken=96d09a1eb7f44a77, processorArchitecture=MSIL" />
+  </ItemGroup>
+</Project>
\ No newline at end of file

Property changes on: class\WindowsBase\WindowsBase tests on Mono - Visual Studio 2005.csproj
___________________________________________________________________
Name: svn:eol-style
   + native

Index: class/WindowsBase/WindowsBase tests - Visual Studio 2005.csproj
===================================================================
--- class/WindowsBase/WindowsBase tests - Visual Studio 2005.csproj	(revision 0)
+++ class/WindowsBase/WindowsBase tests - Visual Studio 2005.csproj	(revision 0)
@@ -0,0 +1,57 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>8.0.50727</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{E72A6595-91A4-493B-9974-6313B81D9C2C}</ProjectGuid>
+    <OutputType>Library</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>
+    </RootNamespace>
+    <AssemblyName>WindowsBase tests - Visual Studio 2005</AssemblyName>
+    <StartupObject>
+    </StartupObject>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>bin\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>bin\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" />
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+       Other similar extension points exist, see Microsoft.Common.targets.
+  <Target Name="BeforeBuild">
+  </Target>
+  <Target Name="AfterBuild">
+  </Target>
+  -->
+  <ItemGroup>
+    <Compile Include="Test\AttachedProperties.cs" />
+    <Compile Include="Test\System.Windows.Threading\DispatcherTest.cs" />
+    <Compile Include="Test\System.Windows\RectTest.cs" />
+    <Compile Include="Test\System.Windows\SizeTest.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="ChangeLog" />
+    <None Include="Makefile" />
+    <None Include="WindowsBase_test.dll.sources" />
+  </ItemGroup>
+  <ItemGroup>
+    <Reference Include="nunit.framework, Version=2.4.2.0, Culture=neutral, PublicKeyToken=96d09a1eb7f44a77, processorArchitecture=MSIL" />
+    <Reference Include="WindowsBase" />
+  </ItemGroup>
+</Project>
\ No newline at end of file

Property changes on: class\WindowsBase\WindowsBase tests - Visual Studio 2005.csproj
___________________________________________________________________
Name: svn:eol-style
   + native

Index: class/WindowsBase/Mono/DoubleListParser.cs
===================================================================
--- class/WindowsBase/Mono/DoubleListParser.cs	(revision 0)
+++ class/WindowsBase/Mono/DoubleListParser.cs	(revision 0)
@@ -0,0 +1,73 @@
+//
+// DoubleListParser.cs: Used by methods such as Size.Parse, Rect.Parse to get
+// double instances from a string.
+//
+// Author:
+//   George Giolfan (georgegiolfan@yahoo.com)
+//
+// Copyright (C) 2007 George Giolfan
+// 
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+using System;
+using System.Globalization;
+namespace Mono
+{
+	/// <summary>
+	/// Used by methods such as <see cref="Size.Parse"/>, <see cref="Rect.Parse"/> to get <see cref="double"/> instances from a string.
+	/// </summary>
+	class DoubleListParser
+	{
+		string text;
+		int current_character_index;
+		char [] separators = new char [] { ' ', ',' };
+
+		public DoubleListParser (string text)
+		{
+			this.text = text ?? string.Empty;
+		}
+
+		public double GetDouble ()
+		{
+			string part = string.Empty;
+			while (part.Length == 0) {
+				if (current_character_index == text.Length)
+					throw new InvalidOperationException ("Premature string termination encountered.");
+				int next_separator_index = text.IndexOfAny (separators, current_character_index);
+				bool has_reached_the_end = next_separator_index == -1;
+				part = (has_reached_the_end ? text.Substring (current_character_index) : text.Substring (current_character_index, next_separator_index - current_character_index)).Trim ();
+				current_character_index = has_reached_the_end ? text.Length : next_separator_index + 1;
+			}
+			double result;
+			if (double.TryParse (part, NumberStyles.Float, NumberFormatInfo.InvariantInfo, out result))
+				return result;
+			else
+				throw new FormatException ("Input string was not in a correct format.");
+		}
+
+		public void CheckForExtraData ()
+		{
+			if (current_character_index == text.Length)
+				return;
+			if (text.Substring (current_character_index).Trim ().Length != 0)
+				throw new InvalidOperationException ("Extra data encountered after token while parsing.");
+		}
+	}
+}
\ No newline at end of file

Property changes on: class\WindowsBase\Mono\DoubleListParser.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Index: class/WindowsBase/System.Windows/Rect.cs
===================================================================
--- class/WindowsBase/System.Windows/Rect.cs	(revision 84156)
+++ class/WindowsBase/System.Windows/Rect.cs	(working copy)
@@ -22,20 +22,24 @@
 // Authors:
 //	Chris Toshok <toshok@novell.com>
 //	Sebastien Pouliot  <sebastien@ximian.com>
+//	George Giolfan <georgegiolfan@yahoo.com>
 //
 
+using Mono;
 using System;
-
+using System.Globalization;
 using System.Windows.Media;
 
 namespace System.Windows {
 
-	public struct Rect {
+	public struct Rect : IFormattable {
 		public Rect (Size size)
 		{
 			x = y = 0.0;
 			width = size.Width;
 			height = size.Width;
+			if (size.IsEmpty)
+				MakeEmpty ();
 		}
 
 		public Rect (Point point, Vector vector) : this (point, Point.Add (point, vector))
@@ -64,6 +68,8 @@
 
 		public Rect (double x, double y, double width, double height)
 		{
+			if (width < 0 || height < 0)
+				throw new ArgumentException ("Width and Height must be non-negative.");
 			this.x = x;
 			this.y = y;
 			this.width = width;
@@ -76,6 +82,8 @@
 			y = location.Y;
 			width = size.Width;
 			height = size.Height;
+			if (size.IsEmpty)
+				MakeEmpty ();
 		}
 
 		public bool Equals (Rect rect)
@@ -134,11 +142,6 @@
 
 		public static Rect Inflate (Rect rect, double width, double height)
 		{
-			if (width < rect.Width * -2)
-				return Rect.Empty;
-			if (height < rect.Height * -2)
-				return Rect.Empty;
-
 			Rect result = rect;
 			result.Inflate (width, height);
 			return result;
@@ -151,12 +154,14 @@
 
 		public void Inflate (double width, double height)
 		{
-			// XXX any error checking like in the static case?
+			this.width += 2 * width;
+			this.height += 2 * height;
+			if (this.width < 0 || this.height < 0) {
+				MakeEmpty ();
+				return;
+			}
 			x -= width;
 			y -= height;
-
-			this.width += 2*width;
-			this.height += 2*height;
 		}
 
 		public void Inflate (Size size)
@@ -166,16 +171,26 @@
 
 		public bool IntersectsWith(Rect rect)
 		{
-			return !((Left >= rect.Right) || (Right <= rect.Left) ||
-			    (Top >= rect.Bottom) || (Bottom <= rect.Top));
+			if (IsEmpty && rect.IsEmpty)
+				return false;
+			return !((Left > rect.Right) || (Right < rect.Left) ||
+			    (Top > rect.Bottom) || (Bottom < rect.Top));
 		}
 
 		public void Intersect(Rect rect)
 		{
+			if (IsEmpty || rect.IsEmpty) {
+				MakeEmpty ();
+				return;
+			}
+			double right = Right;
+			double bottom = Bottom;
 			x = Math.Max (x, rect.x);
 			y = Math.Max (y, rect.y);
-			width = Math.Min (Right, rect.Right) - x;
-			height = Math.Min (Bottom, rect.Bottom) - y; 
+			width = Math.Min (right, rect.Right) - x;
+			height = Math.Min (bottom, rect.Bottom) - y;
+			if (width < 0 || height < 0)
+				MakeEmpty ();
 		}
 
 		public static Rect Intersect(Rect rect1, Rect rect2)
@@ -185,6 +200,11 @@
 			return result;
 		}
 
+		public void Offset (Vector offsetVector)
+		{
+			Offset(offsetVector.X, offsetVector.Y);
+		}
+
 		public void Offset(double offsetX, double offsetY)
 		{
 			x += offsetX;
@@ -198,15 +218,46 @@
 			return result;
 		}
 
+		public static Rect Offset (Rect rect, Vector offsetVector)
+		{
+			return Offset(rect, offsetVector.X, offsetVector.Y);
+		}
+
+		public static Rect Parse(string source) 
+		{
+			DoubleListParser parser = new DoubleListParser (source);
+			Rect result = new Rect (parser.GetDouble (), parser.GetDouble (), parser.GetDouble (), parser.GetDouble ());
+			parser.CheckForExtraData ();
+			return result;
+		}
+
 		public void Scale(double scaleX, double scaleY)
 		{
+			if (IsEmpty)
+				return;
 			x *= scaleX;
 			y *= scaleY;
 			width *= scaleX;
 			height *= scaleY;
 		}
 
-		public void Transform (Matrix matrix)
+		[MonoTODO("Support format, formatProvider.")]
+		string IFormattable.ToString(string format, IFormatProvider formatProvider) {
+			return ToString();
+		}
+
+		public override string ToString() {
+			if (IsEmpty)
+				return "Empty";
+			return string.Join (CultureInfo.CurrentCulture.NumberFormat.NumberDecimalSeparator == "," ? ";" : ",", new string [] { x.ToString (), y.ToString (), width.ToString (), height.ToString () });
+		}
+
+		[MonoTODO("Support provider.")]
+		public string ToString(IFormatProvider provider) {
+			return ToString();
+		}
+
+		public void Transform(Matrix matrix)
 		{
 			throw new NotImplementedException ();
 		}
@@ -234,10 +285,21 @@
 		
 		public void Union(Rect rect)
 		{
+			if (rect.IsEmpty)
+				return;
+			if (IsEmpty) {
+				x = rect.x;
+				y = rect.y;
+				width = rect.width;
+				height = rect.height;
+				return;
+			}
+			double right = Right;
+			double bottom = Bottom;
 			x = Math.Min (x, rect.x);
 			y = Math.Min (y, rect.y);
-			width = Math.Max (Right, rect.Right) - x;
-			height = Math.Max (Bottom, rect.Bottom) - y;
+			width = Math.Max (right, rect.Right) - x;
+			height = Math.Max (bottom, rect.Bottom) - y;
 		}
 
 		public void Union(Point point)
@@ -246,12 +308,16 @@
 		}
 
 		public static Rect Empty { 
-			get { return new Rect (0, 0, 0, 0); } 
+			get {
+				Rect result = new Rect ();
+				result.MakeEmpty ();
+				return result;
+			} 
 		}
 		
 		public bool IsEmpty { 
 			get {
-				return width == 0 || height == 0;
+				return width == double.NegativeInfinity;
 			}
 		}
 		
@@ -270,25 +336,49 @@
 				return new Size (width, height);
 			}
 			set {
+				if (value.IsEmpty) {
+					MakeEmpty ();
+					return;
+				}
 				width = value.Width;
 				height = value.Height;
 			}
 		}
 
 		public double X {
-			get { return X; }
+			get { return x; }
+			set {
+				CheckPropertyAccessOnEmptyRect ();
+				x = value;
+			}
 		}
 
 		public double Y {
 			get { return y; }
+			set {
+				CheckPropertyAccessOnEmptyRect ();
+				y = value;
+			}
 		}
 
 		public double Width {
 			get { return width; }
+			set {
+				CheckPropertyAccessOnEmptyRect ();
+				if (value < 0)
+					throw new ArgumentException ("Width must be non-negative.");
+				width = value;
+			}
 		}
 
 		public double Height {
 			get { return height; }
+			set {
+				CheckPropertyAccessOnEmptyRect ();
+				if (value < 0)
+					throw new ArgumentException ("Height must be non-negative.");
+				height = value;
+			}
 		}
 
 		public double Left { 
@@ -322,10 +412,29 @@
 		public Point BottomRight { 
 			get { return new Point (Bottom, Right); }
 		}
-		
+
+		/* operators */
+		public static bool operator == (Rect rect1, Rect rect2) {
+			return Equals (rect1, rect2);
+		}
+
+		public static bool operator !=(Rect rect1, Rect rect2) {
+			return !(rect1 == rect2);
+		}
+
 		double x;
 		double y;
 		double width;
 		double height;
+
+		void CheckPropertyAccessOnEmptyRect () {
+			if (IsEmpty)
+				throw new InvalidOperationException ("Cannot modify this property on the Empty Rect.");
+		}
+
+		void MakeEmpty() {
+			x = y = double.PositiveInfinity;
+			width = height = double.NegativeInfinity;
+		}
 	}
 }

Property changes on: class\WindowsBase\System.Windows\Rect.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Index: class/WindowsBase/System.Windows/Size.cs
===================================================================
--- class/WindowsBase/System.Windows/Size.cs	(revision 84156)
+++ class/WindowsBase/System.Windows/Size.cs	(working copy)
@@ -21,9 +21,12 @@
 //
 // Authors:
 //	Chris Toshok (toshok@novell.com)
+//	George Giolfan (georgegiolfan@yahoo.com)
 //
 
+using Mono;
 using System;
+using System.Globalization;
 
 namespace System.Windows {
 
@@ -34,6 +37,8 @@
 	{
 		public Size (double width, double height)
 		{
+			if (width < 0 || height < 0)
+				throw new ArgumentException ("Width and Height must be non-negative.");
 			this.width = width;
 			this.height = height;
 		}
@@ -61,26 +66,62 @@
 			throw new NotImplementedException ();
 		}
 
-		string IFormattable.ToString(string format, IFormatProvider formatProvider) {
-			throw new NotImplementedException ();
+		public static Size Parse(string source)
+		{
+			DoubleListParser parser = new DoubleListParser (source);
+			Size result = new Size (parser.GetDouble (), parser.GetDouble ());
+			parser.CheckForExtraData ();
+			return result;
 		}
 
+		[MonoTODO("Support format, formatProvider.")]
+		string IFormattable.ToString(string format, IFormatProvider formatProvider)
+		{
+			return ToString ();
+		}
+
+		public override string ToString ()
+		{
+			if (IsEmpty)
+				return "Empty";
+			return width + (CultureInfo.CurrentCulture.NumberFormat.NumberDecimalSeparator == "," ? ";" : ",") + height;
+		}
+
+		[MonoTODO("Support provider.")]
+		public string ToString(IFormatProvider provider)
+		{
+			return ToString();
+		}
+
 		public bool IsEmpty {
-			get { return width == 0.0 && height == 0.0; }
+			get { return double.IsNegativeInfinity (width); }
 		}
 
 		public double Height {
 			get { return height; }
-			set { height = value; }
+			set {
+				if (value < 0)
+					throw new ArgumentException ("Height must be non-negative.");
+				height = value; 
+			}
 		}
 
 		public double Width {
 			get { return width; }
-			set { width = value; }
+			set {
+				if (value < 0)
+					throw new ArgumentException ("Width must be non-negative.");
+				width = value; 
+			}
 		}
 
 		public static Size Empty {
-			get { return new Size (0, 0); }
+			get {
+				Size result = new Size ();
+				result.width = double.NegativeInfinity;
+				result.height = double.NegativeInfinity;
+				return result;
+			}
 		}
 
 		/* operators */

Property changes on: class\WindowsBase\System.Windows\Size.cs
___________________________________________________________________
Name: svn:eol-style
   + native

Index: class/Windows Presentation Foundation - Visual Studio 2005.sln
===================================================================
--- class/Windows Presentation Foundation - Visual Studio 2005.sln	(revision 0)
+++ class/Windows Presentation Foundation - Visual Studio 2005.sln	(revision 0)
@@ -0,0 +1,32 @@
+﻿
+Microsoft Visual Studio Solution File, Format Version 9.00
+# Visual C# Express 2005
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "WindowsBase - Visual Studio 2005", "WindowsBase\WindowsBase - Visual Studio 2005.csproj", "{9462AA4B-7F15-46B5-98A3-28832667B7BA}"
+EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "WindowsBase tests - Visual Studio 2005", "WindowsBase\WindowsBase tests - Visual Studio 2005.csproj", "{E72A6595-91A4-493B-9974-6313B81D9C2C}"
+EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "WindowsBase tests on Mono - Visual Studio 2005", "WindowsBase\WindowsBase tests on Mono - Visual Studio 2005.csproj", "{1FC4703A-6989-463D-BB92-6AF2DD9ABF6B}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Any CPU = Debug|Any CPU
+		Release|Any CPU = Release|Any CPU
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{9462AA4B-7F15-46B5-98A3-28832667B7BA}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{9462AA4B-7F15-46B5-98A3-28832667B7BA}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{9462AA4B-7F15-46B5-98A3-28832667B7BA}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{9462AA4B-7F15-46B5-98A3-28832667B7BA}.Release|Any CPU.Build.0 = Release|Any CPU
+		{E72A6595-91A4-493B-9974-6313B81D9C2C}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{E72A6595-91A4-493B-9974-6313B81D9C2C}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{E72A6595-91A4-493B-9974-6313B81D9C2C}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{E72A6595-91A4-493B-9974-6313B81D9C2C}.Release|Any CPU.Build.0 = Release|Any CPU
+		{1FC4703A-6989-463D-BB92-6AF2DD9ABF6B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{1FC4703A-6989-463D-BB92-6AF2DD9ABF6B}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{1FC4703A-6989-463D-BB92-6AF2DD9ABF6B}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{1FC4703A-6989-463D-BB92-6AF2DD9ABF6B}.Release|Any CPU.Build.0 = Release|Any CPU
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal

Property changes on: class\Windows Presentation Foundation - Visual Studio 2005.sln
___________________________________________________________________
Name: svn:eol-style
   + native

